# .github/workflows/daily-exercise-generator.yml
name: Daily Exercise Generator

on:
  schedule:
    - cron: "0 7 * * 1-5"          # Run on weekdays at 07:00 UTC (≈ 09:00 Berlin in summer)
  workflow_dispatch:               # Allow manual trigger from the Actions tab

permissions:                       # Defaults for all jobs (overridable per job)
  contents: write                  # Needed to commit the generated file
  issues: write                    # Needed to open a GitHub Issue

jobs:
  generate-and-issue:
    runs-on: ubuntu-latest         # Fresh Linux VM runner
    steps:
      - name: Checkout             # Clone repo into runner workspace
        uses: actions/checkout@v4
        with:
          persist-credentials: true  # Keep GITHUB_TOKEN in .git config for later push

      - name: Set up Python        # Provide a predictable Python runtime
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies # OpenAI SDK used by the inline Python
        run: pip install --upgrade openai

      - name: Generate index-based pointer exercise as C file (no spoilers)
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          python - << 'PY'
          import re, hashlib, textwrap
          from pathlib import Path
          from openai import OpenAI

          root = Path(".")
          ex_dir = root / "exercises"
          ex_dir.mkdir(exist_ok=True)

          existing = []
          for p in ex_dir.glob("exercise-*.c"):
              m = re.match(r"exercise-(\d{2})\.c$", p.name)
              if m:
                  existing.append(int(m.group(1)))
          idx = 0 if not existing else max(existing) + 1
          if idx >= 12:
              print("All 12 exercises already generated. Exiting.")
              raise SystemExit(0)

          out_c = ex_dir / f"exercise-{idx:02d}.c"

          history = []
          for p in sorted(ex_dir.glob("exercise-*.c")):
              try:
                  head = (p.read_text(encoding="utf-8", errors="ignore")).splitlines()[:30]
                  head_text = "\n".join(head)
                  sig = hashlib.sha1(head_text.encode("utf-8")).hexdigest()[:10]
                  title = next((ln.strip() for ln in head if ln.strip().startswith("Title:")), "(no-title)")
                  history.append(f"{p.name}: {title} (sig:{sig})")
              except Exception:
                  pass

          system = """You are a rigorous C tutor generating ONE focused daily exercise.
          RULES:
          - Scope: C pointers only (pointer-to-pointer T**, array-to-pointer decay, const-correctness on pointers,
            function parameter semantics & ownership, malloc/free + lifetime, small pointer arithmetic, passing arrays,
            void* boundaries; optional brief function-pointer quirks). Keep exercises micro-sized.
          - Absolutely NO algorithms or data structures (no linked lists, stacks, queues, hash tables, sorting, etc.).
          - No solutions. No hints. No starter code. No TODOs.
          - Output must be plain text suitable for embedding inside a C block comment.
          - Provide: Title, Learning Objective (≤2 lines), Constraints, Problem Statement,
            and 3–5 Scenario Checks (expected behavior described in prose, NOT code)."""

          user = f"""Create exercise #{idx:02d} (3–15 lines of code expected to solve).
          Prioritize reasoning: when to pass T* vs T**, const placement, aliasing/ownership, correct lifetime decisions.
          Do NOT repeat previous exercises' semantics. Previous files:
          {(chr(10)).join(history) if history else "(none)"}"""

          client = OpenAI()
          resp = client.chat.completions.create(
              model="gpt-4o-mini",
              temperature=0.6,
              messages=[
                  {"role":"system","content":system},
                  {"role":"user","content":user},
              ],
          )
          prompt = resp.choices[0].message.content.strip()

          # Keep these lines INDENTED so YAML treats them as part of the heredoc.
          content = f"""/* 
            Title: (exercise {idx:02d})
            {prompt}

            INSTRUCTIONS:
            - Implement your solution in this file below.
            - Do NOT add TODO markers; write your own minimal code.
            - Keep it focused on the pointer concept; no algorithms.
          */

          #include <stdio.h>
          #include <stdlib.h>

          int main(void) {
              // Write your few lines here. Keep it minimal and pointer-focused.
              return 0;
          }
          """
          out_c.write_text(textwrap.dedent(content), encoding="utf-8")
          print(f"Wrote {out_c}")
PY